#include <stdio.h>
#include <reason.h>
#include <windows.h>

#include "log.h"
#include "str.h"
#include "util.h"

bool
get_program_name(char *buf, int len)
{
	int ret;
	ret = GetModuleFileName(NULL, buf, len);
	if (ret > 0)
		return true;
	else
		return false;
}

void
my_sleep(int seconds)
{
	Sleep(seconds * 1000);
}

void
my_usleep(int useconds)
{
	Sleep(useconds / 1000);

}

bool
get_system_info(char buf[SYSINFO_SZ])
{
	SYSTEM_INFO info;
	int ret, ver;

	char os[] = "Windows ";
	char proc[3][100] = {"Intel x86\n", "Intel x64\n", "other\n"};
	char *cproc;

	memcpy(buf, os, strlen(os));
	buf += strlen(os);


	ver = GetVersion();

	ret = sprintf(buf, "%2.2x.%2.2x\n", ver & 0xff00, ver & 0xff);
	if (ret < 0)
		return false;
	buf += ret;

	GetSystemInfo(&info);

	switch (info.wProcessorArchitecture) {
	case PROCESSOR_ARCHITECTURE_INTEL:
		cproc = proc[0];
		break;
	case PROCESSOR_ARCHITECTURE_AMD64:
		cproc = proc[1];
		break;
	default:
		cproc = proc[2];
		break;
	}
	memcpy(buf, cproc, strlen(cproc));
	buf += strlen(cproc);
	buf[0] = '\0';

	return true;
}

void
pc_reboot()
{
	HANDLE tok;
	TOKEN_PRIVILEGES tkp;
	int ret;
	//Only works if account have necessary privilegies.
	if (!OpenProcessToken(GetCurrentProcess(),
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		&tok)) {
		DEBUG(LOG_DEFAULT, "can't open process tok\n");
		win_perror("errmsg ");
		return;
	}
	LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME,
		&tkp.Privileges[0].Luid);

	tkp.PrivilegeCount = 1;  // one privilege to set
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	ret = AdjustTokenPrivileges(tok, false, &tkp, 0,
		NULL, 0);
	if (ret == false) {
		DEBUG(LOG_DEFAULT, "Can't adjust tok privs\n");
		return;
	}

	//FIXME
	//ret = ExitWindowsEx(EWX_REBOOT |EWX_FORCE, SHTDN_REASON_MAJOR_OTHER);
	if (ret != 0)
		DEBUG(LOG_DEFAULT, "rebooting system\n");
	else
		DEBUG(LOG_DEFAULT, "reboot error\n");
}


bool
pipe_set_blocking(HANDLE pipe, bool blocking)
{
	int ret;
	int mode = 0;

	if (blocking == true)
		mode = PIPE_WAIT;
	else
		mode = PIPE_NOWAIT;

	ret = SetNamedPipeHandleState(pipe,
	    (LPDWORD )&mode, //lpmode
	    NULL,
	    NULL);
	printf("get last error %d\n", (int )GetLastError());
	if (ret == 0)
		return false;
	else
		return true;
}

void
win_perror(char *str)
{
	char msg[128];

	fprintf(stderr, "%s: ", str);

	win_strerror(msg, sizeof(msg));
	fprintf(stderr, "%s\n", msg);
}

char *
win_strerror(char *buf, int sz)
{
	int err = 0;

	err = GetLastError();

	FormatMessage(
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            err,
            MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
            (LPTSTR) buf,
            sz, NULL );
	DEBUG(LOG_VERBOSE, "win_strerror:%s(%d)\n", buf, err);
	return buf;
}

bool
my_atoi(char *ptr, int *n)
{
	*n = 0;
	while (*ptr != '\0') {
		printf("-%c-", *ptr);
		if (*ptr < '0' || *ptr > '9')
			return false;
		*n = *n * 10 + *ptr - '0';
		ptr++;
	}
	return true;
}

bool
get_home_dir(char *buf, int len)
{
	DEBUG(LOG_DEFAULT, "FIXME: now just get tmp dir\n");
	//FIXME: need to get home dir
	if (GetTempPath(len, buf) == 0)
		return false;
	return true;
}

int
get_tick_count()
{
	return GetTickCount();
}


char alph_printable[] = "0123456789abcdefghijklmnopqrstuvwxyz";

char
rand_get_char_printable()
{
	int i;

	i = get_tick_count() % str_len(alph_printable);
	return alph_printable[i];
}

