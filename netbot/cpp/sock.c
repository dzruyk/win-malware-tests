#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <winsock2.h>

#include "common.h"
#include "log.h"
#include "sock.h"

bool Socketlib_init(void)
{
	WSADATA data;

	//Winapi magic we ask for use lib version 2.2 or later
	WSAStartup(MAKEWORD(2, 2), &data);

	return true;
}

bool Socketlib_uninit(void)
{
	WSACleanup();

	return true;
}

void
socket_init(struct socket *s)
{
	s->sock = 0;
	s->serv_port = 
	    s->client_ip = s->client_port = 0;
	
	//some default values
	s->sock_domain = AF_INET;
	s->sock_type = SOCK_STREAM;
	s->serv_port = 0;
	s->serv_ip = 0;

	s->is_closed = 1;
}

bool socket_create_socket(struct socket *s)
{

	return true;
}

bool socket_get_sock(struct socket *s, int *sock)
{
	if (s->sock == 0) {
		DEBUG(LOG_DEFAULT, "Seems like socket not created\n");
		return false;
	}
	if (s->is_closed == 1) {
		DEBUG(LOG_DEFAULT, "Seems like socket closed\n");
		return false;
	}
	*sock = s->sock;

	return true;
}

bool socket_set_ip(struct socket *s, char *serv_ip)
{
	s->serv_ip = inet_addr(serv_ip);
	
	if (s->serv_ip == INADDR_NONE)
		return false;
	
	return true;
}

bool socket_set_port(struct socket *s, char *serv_port)
{
	DEBUG(LOG_VERBOSE, "Socket set port\n");
	uint16_t port;
//FIXME:
	port = atoi(serv_port);

	s->serv_port = htons(port);
	
	return true;
}

bool socket_connect(struct socket *s)
{
	struct sockaddr_in addr;
	int ret;
	SOCKET sock;

	if (s->sock != 0) {
		DEBUG(LOG_DEFAULT, "Seems like socket already connected\n");
		return false;
	}
	if (s->serv_ip == 0 
	    && s->serv_port == 0) {
		DEBUG(LOG_VERBOSE, "serv port or sert ip undefined yet\n");
		return false;
	}

	sock = socket(s->sock_domain, s->sock_type, 0);
	
	if (sock == INVALID_SOCKET) {
		DEBUG(LOG_DEFAULT, "can't create socket\n");
		perror("");
		return false;
	}
	s->sock = sock;
	s->is_closed = 0;

	addr.sin_family = s->sock_domain;
	addr.sin_port = s->serv_port;
	addr.sin_addr.s_addr = s->serv_ip;

	ret = connect(s->sock, (const struct sockaddr *)&addr, sizeof(addr));

	if (ret == -1) {
		DEBUG(LOG_DEFAULT, "can't connect to server: %s\n", strerror(errno));
		socket_close(s);
		return false;
	}

	DEBUG(LOG_VERBOSE, "Socket connection success\n");

	return true;
}


bool socket_send_msg(struct socket *s, void *msg, int len)
{
	assert(s->sock != 0);
	int ret, sended;

	sended = 0;

	do {
		ret = send(s->sock, msg, len, 0);
		if (ret == -1)
			goto err;
		msg += ret;
	} while ((sended += ret) < len);

	return true;
err:
	s->is_closed = 1;
	return false;
}

bool socket_recv_msg(struct socket *s, void *msg, int *len, int maxlen)
{
	assert(s->sock != 0);

	int ret;
	fd_set rfds;
	struct timeval t;

	if (s->is_closed == 1) {
		DEBUG(LOG_DEFAULT, "connection already closed\n");
		return false;
	}

	FD_ZERO(&rfds);
	FD_SET(s->sock, &rfds);

	t.tv_sec = 60;
	t.tv_usec = 0;

	ret = select(1, &rfds, NULL, NULL, &t);
	if (ret == SOCKET_ERROR) {
		DEBUG(LOG_DEFAULT, "socket error on select\n");
		return false;
	} else if (ret == 0) {
		DEBUG(LOG_DEFAULT, "timeout ended on recv\n");
		return false;
	}

	ret = recv(s->sock, msg, maxlen, 0);
	if (ret == -1)
		goto err;

	if (ret == 0) {
		s->is_closed = 1;
		goto err;
	}

	*len = ret;

	DEBUG(LOG_VERBOSE, "recvived %d bytes\n", ret);
	
	return true;
err:
	DEBUG(LOG_VERBOSE, "recv error\n");
	s->is_closed = 1;

	return false;
}


bool socket_recv_all(struct socket *s, void *msg, int len)
{
	int recived;

	assert(s->sock != 0);

	 do {
		if (!socket_recv_msg(s, msg, &recived, len))
			return false;
		len -= recived;
		msg += recived;
	} while (len > 0);

	return true;
}

bool socket_recv_line(struct socket *s, void *msg, int *len, int maxlen)
{
	char *buf;
	char ch;
	int i;

	buf = msg;
	for (i = 0; i < maxlen - 1; i++) {
		if (!socket_recv_all(s, &ch, 1))
			return false;
		*buf++ = ch;
		if (ch == '\n')
			break;
	}
	*buf = '\0';
	*len = i + 1;

	return true;
}

bool socket_close(struct socket *s)
{
	assert(s->sock != 0);

	closesocket(s->sock);

	s->sock = 0;

	return true;
}

