Netbot description
==================

Общая структура
---------------

* netbot.exe - Главный бинарник ( по совместительству core module). Подгружает остальные модули;
* modules (fs_grabber.dll, spy.dll, vnc.dll) Модули, скачиваются при необходимости с сервера. 
Информация о установленных модулях хранится в конфиге netbot;
* Дополнительные библиотеки (regex.dll, screenshots.dll). 
Содержат полезные функции (о которых знают модули).
Вместе с модулем сервер должен попытаться предоставить все необходимые библиотеки.


Модули
------


Core
~~~~

Корневой модуль. Даже без остальных модулей обладает всем необходимым для удалённого администрирования и получения дальнейших команд.

Функции:

* Система обмена информацией с другими модулями
* Связь с сервером
* Криптография
* Инсталяция, деинсталяция
* Работа с конфигурационными файлами
* Эксплойты для внедрения (мб вынести в отдельный модуль или отдельно сделать дроппер?)


fs_grabber
~~~~~~~~~~

Ищет файлы на дисках по определённому шаблону в фоновом режиме без нагрузки на систему.

Требует dll:

* regex.dll


http_grabber
~~~~~~~~~~

Находит и копирует информацию о cookies, паролях и возможно о посещённых страницах.


vnc
~~~

Удалённый доступ к машине по VNC.

spy
~~~

Включает в себя кейлоггер и скринсейвер.



API
---

modules public API
~~~~~~~~~~~~~~~~~~

----
MODNAME_init(const struct bot *bot, void *data);
MODNAME_finalize();
----

MODNAME_init() - инициализирет модуль MODNAME. 
Должна запускаться в отдельном треде.
Для предотвращения нестабильной работы модулю не желательно создавать дополнительные
треды и изменять "чужие" глобальные переменные (в том числе и главнго модуля)

MODNAME_finalize() - опциональный деструктор

Core module
~~~~~~~~~~~

Связь с сервером
^^^^^^^^^^^^^^^^

Для повышения гибкости доступа для связи с сервером API должно легко позволять интегрировать
новые протоколы, например:

* TCP
* UDP
* ICMP
* HTTP

Для каждого из протоколов должны быть написаны обвёртки со стандартизированным API над их вызовами.
При инициализации бота выбирается протокол для взаимодействия и в структуру _bot->network_ заносятся указатели на необходимые функции.

Сама структура выглядит следующим образом

----
struct network {
	void *ctx;
	void (*net_init)(void *ctx);
	int (*send)(void *ctx, char *buf, int sz);
	...
	

};
----

API:

----

net_init() - конструктор 
net_finalize() - деструктор

net_set_params()
net_connect()
net_disconnect() /* or close */
net_send()
net_send_async()
net_recv()
net_recv_async()
----

Ремарка: На текущий момент можно ограничится реализацией TCP.

Ремарка: Совсем не думал про p2p сети. что-то подсказывает что такого
API всё-равно будет достаточно.


Отдельно можно выделить:

----
net_auth() - функция для авторизации
----



Конфигурационные файлы
^^^^^^^^^^^^^^^^^^^^^^

Сервер посылает боту конфигурационные файлы в которых описаны детали его поведения.
Для простоты в данный момент конфиг файл это простой текстовый файл с *.ini синтаксисом.

Конфиг делится на секции. Имя секции указывает для какого из модулей написаны инструкции.
Сами инструкции это пары ключ - значение разделённые знаком = и любым количеством пробелов и
табуляций.

Комментарии в конфиге начинаются с '//' или '#'
Например:

----
[CORE]
proto=tcp

alternative_server_ip=8.8.8.8 // может быть не стоит адрес серверов задавать в конфиге
			      // кроме того адреса по умолчанию стоит хранить в самом бинарнике.

[fs_grabber]
search_pattern
----

Криптография
------------

Особенно не прорабатывал. И клиент и сервер должны быть уверенны что вторая сторона доверенная.

Можно подобные вопросы отложить в долгий ящик.



Инсталяция на целевой хост
-------------------------

2 Варианта: 

* запись вызывающего кода в exeшник популярных программ (notepad, explorer, etc);
* реестровая магия.

Ничего не тестировал, надо буте почитать литературу и решить что лучше.

