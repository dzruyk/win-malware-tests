#include "stdafx.h"

#include <stdio.h>
#include <Windows.h>
#include <TlHelp32.h>

#include "coreinject.h"
#include "log.h"
#include "peutils.h"
#include "test_inj.h"


extern DWORD WINAPI injected_thread(LPVOID data);

bool
inject_into_process(int pid)
{
	HANDLE proc, thread;
	bool ret;
	ret = false;
	
	proc = OpenProcess(PROCESS_QUERY_INFORMATION |
	    PROCESS_VM_OPERATION |
	    PROCESS_VM_WRITE |
	    PROCESS_VM_READ |
	    PROCESS_CREATE_THREAD |
	    PROCESS_DUP_HANDLE,
	    FALSE, pid);

	if (proc == NULL) {
		return false;
	}
	
	void *newmod = copy_module_to_process(proc, mainCtx.current_module);

	if (newmod == NULL) {
		DEBUG(LOG_DEFAULT, "[-] copy module to process fail\n");
		return false;
	}
	DEBUG(LOG_DEFAULT, "[+] Remote module memory = %p\n", newmod);

	DWORD_PTR entry = ((DWORD_PTR)injected_thread) -
	    ((DWORD_PTR)mainCtx.current_module) + ((DWORD_PTR)newmod);

	DEBUG(LOG_DEFAULT, "[+] Remote thread entry =  %p\n", entry);

	//
	if (!copy_data_to_process(proc,
	    newmod,
	    &mainCtx.current_module,
	    &newmod,
	    sizeof(HMODULE))) {
		DEBUG(LOG_DEFAULT, "[-] Can't copy data to process\n");
		return false;
	}

	thread = CreateRemoteThread(proc,
	    NULL,
	    0,
	    (LPTHREAD_START_ROUTINE)entry,
	    NULL,
	    0,
	    NULL);
	if (thread == NULL)
		goto finalize;

	CloseHandle(thread);

	ret = true;

finalize:
	CloseHandle(proc);
	return true;
}


bool
copy_data_to_process(HANDLE proc, void *img, void *cur_va, void *data, DWORD sz)
{
	DWORD_PTR rva = (DWORD_PTR)(((LPBYTE)cur_va) - ((LPBYTE)mainCtx.current_module));
	return (WriteProcessMemory(proc,
	    (LPBYTE)img + rva,
	    data,
	    sz,
	    NULL) == FALSE) ? false : true;
}

int
EnableWrite(int* offset, int size)
{
	unsigned long prevPerm;

	if(!VirtualProtect(offset, size, PAGE_EXECUTE_READWRITE, &prevPerm)) 
		return 0;
	return prevPerm;
}
