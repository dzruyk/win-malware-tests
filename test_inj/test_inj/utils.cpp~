#include "stdafx.h"

#include <Windows.h>

#include "test_inj.h"

static void *
asm_GetKernel32Handle()
{
#ifdef _WIN64
	return NULL; //FIXME
#else

__asm
{
	push esi
	push edi
	cld			//clear direction flag
	mov edx, fs:[0x30]	//ptr to PEB info from zeus and
				//http://en.wikipedia.org/wiki/Win32_Thread_Information_Block
	mov edx, [edx + 0x0c]	//PEB->ldr
	mov edx, [edx + 0x14]	//ldr->InMemoryOrderModuleLis
	mov ebx, edx		//memorize start point
	
next_mod:
	mov ecx, 24
	mov esi, [edx + 0x28]	//get ptr to modname
	xor edi, edi

loop_modname:
	xor eax, eax           //clear eax
	lodsb                  //read in the next byte of the name
	cmp al, 'a'            //some versions of Windows use lower case module names
	jl not_lowercase
	sub al, 0x20           //if so normalise to uppercase
  
not_lowercase:
	ror edi, 13            //rotate right our hash value
	add edi, eax           //add the next byte of the name to the hash
	loop loop_modname      //loop until we have read enough
	
	cmp edi, 0x6A4ABC5B    //compare the hash with that of KERNEL32.DLL
	mov eax, [edx + 0x10]  //get this modules base address
	mov edx, [edx]         //get the next module
	je end

	mov edx, [edx]		// ldr = ldr->next
	cmp ebx, edx		//cmp with first ldr
	jne next_mod
	mov eax, 0
end:
	pop edi
	pop esi
}

#endif
}

bool
ctx_renew()
{
	mainCtx.handles.current_handle = GetCurrentProcess();


	mainCtx.handles.kernel32_prev = mainCtx.handles.kernel32;

	mainCtx.handles.kernel32 = asm_GetKernel32Handle();
	if (mainCtx.handles.kernel32_prev == 0)
		mainCtx.handles.kernel32_prev = mainCtx.handles.kernel32;
	mainCtx.handles.kernel32_prev = 
	//we wish to suppress any output by default
	mainCtx.suppress_output = 1;

	return true;
}

LPVOID
xmalloc(size_t sz)
{
	LPVOID p;

	p = malloc(sz);
	if (p == NULL)
		exit(1);
	return p;
}

LPVOID
dup_memory(LPVOID src, DWORD len)
{
	LPVOID dst;

	dst = xmalloc(len);

	CopyMemory(dst, src, len);

	return dst;
}

LPVOID 
memset(LPVOID s, BYTE c, DWORD n)
{
	LPBYTE ptr;

	ptr = (LPBYTE) s;
	for (; n > 0; n--)
		*ptr++ = c;
	
	return s;
}
