#include "stdafx.h"

#include <Windows.h>
#include "log.h"
#include "str.h"
#include "test_inj.h"

static void *
asm_GetKernel32Handle()
{
#ifdef _WIN64
	return NULL; //FIXME
#else

__asm
{
	push esi
	push edi
	cld			//clear direction flag
	mov edx, fs:[0x30]	//ptr to PEB info from zeus and
				//http://en.wikipedia.org/wiki/Win32_Thread_Information_Block
	mov edx, [edx + 0x0c]	//PEB->ldr
	mov edx, [edx + 0x14]	//ldr->InMemoryOrderModuleLis
	mov ebx, edx		//memorize start point
	
next_mod:
	mov ecx, 24
	mov esi, [edx + 0x28]	//get ptr to modname
	xor edi, edi

loop_modname:
	xor eax, eax           //clear eax
	lodsb                  //read in the next byte of the name
	cmp al, 'a'            //some versions of Windows use lower case module names
	jl not_lowercase
	sub al, 0x20           //if so normalise to uppercase
  
not_lowercase:
	ror edi, 13            //rotate right our hash value
	add edi, eax           //add the next byte of the name to the hash
	loop loop_modname      //loop until we have read enough
	
	cmp edi, 0x6A4ABC5B    //compare the hash with that of KERNEL32.DLL
	mov eax, [edx + 0x10]  //get this modules base address
	mov edx, [edx]         //get the next module
	je end

	mov edx, [edx]		// ldr = ldr->next
	cmp ebx, edx		//cmp with first ldr
	jne next_mod
	mov eax, 0
end:
	pop edi
	pop esi
}

#endif
}

#if IS_DEBUG > 0

void
ctx_debug_renew()
{
	debugCtx.fopen = (FILE *(*)(const char *, const char *))
	    CWA("MSVCR100", fopen);
	debugCtx.fwrite = (size_t (*)(const void *, size_t, size_t, FILE *))
	   CWA("MSVCR100", fwrite); 
	debugCtx.fclose = (int (*)(FILE *))
	   CWA("MSVCR100", fclose);
	
	debugCtx.fwprintf = (int (*)(FILE *, const wchar_t *, ...))
	    CWA("MSVCR100", fwprintf);
	debugCtx.fflush = (int (*)(FILE *))
	    CWA("MSVCR100", fflush);
}
#endif

bool
ctx_renew()
{
	mainCtx.handles.current_handle = GetCurrentProcess();

	mainCtx.handles.kernel32 = asm_GetKernel32Handle();

#if IS_DEBUG > 0
	ctx_debug_renew();
#endif
	return true;
}

LPVOID
xmalloc(size_t sz)
{
	LPVOID p;

	p = malloc(sz);
	if (p == NULL)
		exit(1);
	return p;
}

LPVOID
xrealloc(LPVOID *ptr, size_t sz) 
{
        void *tmp;
        if ((tmp = realloc(ptr, sz)) == NULL)
		exit(1);
        return tmp;
}

LPVOID
dup_memory(LPVOID src, DWORD len)
{
	LPVOID dst;

	dst = xmalloc(len);

	CopyMemory(dst, src, len);

	return dst;
}

LPVOID 
memset(LPVOID s, BYTE c, DWORD n)
{
	LPBYTE ptr;

	ptr = (LPBYTE) s;
	for (; n > 0; n--)
		*ptr++ = c;
	
	return s;
}

int
get_tick_count()
{
	return GetTickCount();
}

wchar_t alph_printable[] = L"0123456789abcdefghijklmnopqrstuvwxyz";

char
rand_get_char_printable()
{
	int i;

	i = get_tick_count() % str_len(alph_printable);

	return alph_printable[i];
}
