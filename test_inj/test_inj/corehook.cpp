#include "stdafx.h"

#include <Ws2tcpip.h>
#include <Windows.h>
#include <Winhttp.h>


#include <stdio.h>

#include "common.h"
#include "corehook.h"
#include "disassm.h"
#include "log.h"
#include "peutils.h"
#include "test_inj.h"

#pragma comment(lib, "winhttp")
#pragma comment(lib, "ws2_32")

HANDLE WINAPI CreateFile_hook( LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile)
{
	
	DEBUG(LOG_DEFAULT, "Fopen Hooked\n");

	return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
	    dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HINTERNET WINAPI WinHttpConnect_hook(
    HINTERNET hSession,
    LPCWSTR pswzServerName,
    INTERNET_PORT nServerPort,
    DWORD dwReserved)
{
	DEBUG(LOG_DEFAULT, "WinHttpConnect Hooked\n");

	return WinHttpConnect(
	    hSession,
	    L"google.ru",
	    nServerPort,
	    dwReserved);
}

int WSAAPI getaddrinfo_hook(
    PCSTR pNodeName,
    PCSTR pServiceName,
    const ADDRINFOA *pHints,
    PADDRINFOA *ppResult
)
{
	DEBUG(LOG_DEFAULT, "getaddrinfo Hooked\n");

	return getaddrinfo("google.ru", pServiceName, pHints, ppResult);
}

DWORD
hook_function(HANDLE proc, void *target, void *replacement, void *original)
{
	DWORD oldProtect;
	BYTE buf[OPCODE_MAX_SIZE * 2 + JMP_ADDR_SIZE];
	DWORD bytes_used = 0;
	DWORD offset;

	if (!VirtualProtectEx(proc,
	    target,
	    OPCODE_MAX_SIZE * 2,
	    PAGE_EXECUTE_READWRITE,
	    &oldProtect)) {
		DEBUG(LOG_DEFAULT, "can't set access rights to target function: %d\n",
			GetLastError());
		return false;
	}

	memset(buf, 0x90, sizeof(buf));
  
	if(ReadProcessMemory(proc, 
	    target, 
	    buf,
	    OPCODE_MAX_SIZE * 2,
	    NULL) == 0) {
		DEBUG(LOG_DEFAULT, "can't read process memory: %d\n",
			GetLastError());
		goto finalize;
	}

	//read opcodes
	for (offset = 0; offset < INJECT_SIZE;) {
		LPBYTE curopcode;
		int len;

		curopcode = buf + offset;
		
		if ((len = get_opcode_len(curopcode)) == -1) {
			goto finalize;
		}

		DEBUG(LOG_VERBOSE, "readed instruction len = %d\n", len);
		offset += len;

#if IS_DEBUG == 1
		int i;
		for (i = 0; i < len; i++)
			DEBUG(LOG_VERBOSE, "%2.2x ", 0xff & curopcode[i]);
		DEBUG(LOG_VERBOSE,"\n");
#endif


		if (offset > sizeof(buf) - JMP_ADDR_SIZE)
			goto finalize;

		//if opcode is Relative CALL or JMP instruction:
		if((curopcode[0] == 0xE9 ||
		    curopcode[0] == 0xE8) &&
		    len == 1 + sizeof(DWORD)) { //FIXME: не уверен для x64.

			DEBUG(LOG_DEFAULT, "Relative JMP/CALL(%02X) detected.", curopcode[0]);

			DWORD *relAddrSet = (DWORD *)(curopcode + 1);
			DWORD_PTR to = (*relAddrSet) + ((DWORD_PTR)target + offset);
			*relAddrSet = (DWORD)(to - ((DWORD_PTR)target + offset));
		}
	}

	{
		LPBYTE pjmp = buf + offset;
		//Jums from last saved instruction in original to continuation of target function
		WRITE_JMP(pjmp, original, target);
		if(WriteProcessMemory(proc, original, buf, offset + JMP_ADDR_SIZE, NULL) == 0)
			goto finalize;
	}

	WRITE_JMP(buf, target, replacement);
	if (WriteProcessMemory(proc, target, buf, INJECT_SIZE, NULL) == 0) {
		DEBUG(LOG_DEFAULT, "can't write result to process memory\n");
		goto finalize;
	}

	if (!patch_iat(mainCtx.current_module, target, original)) {
		DEBUG(LOG_DEFAULT, "patch function error\n");
	}


	bytes_used += offset + JMP_ADDR_SIZE;
finalize:
	if (!VirtualProtectEx(proc, target, OPCODE_MAX_SIZE * 2, oldProtect, NULL)) {
		DEBUG(LOG_DEFAULT, "can't bring back access rights: %d\n",
		    GetLastError());
		//return false;
	}

	return bytes_used;
}


static struct hook_list
{
	wchar_t *dllname;
	char *fn_name;
	void *fn_target;
	void *fn_replacement;
} lst[] = {
	{L"kernel32.dll", "CreateFileW", NULL, CreateFile_hook},
	{L"winhttp.dll", "WinHttpConnect", NULL, WinHttpConnect_hook},
	{L"ws2_32", "getaddrinfo", NULL, getaddrinfo_hook}
};


static void
init_hook_list()
{
	int i;
	int len;

	len = ARRSZ(lst);

	for (i = 0; i < len; i++) {

		lst[i].fn_target =
		    getFunctionAddress(lst[i].dllname, lst[i].fn_name, 0);
	}
}

bool
hook_all(HANDLE proc)
{
	int i, sz, used;
	void *orig_buf;

	DEBUG(LOG_VERBOSE, "[+] Try to do some hooks\n");

	init_hook_list();

	used = 0;
	sz = ARRSZ(lst);

	orig_buf = allocRemoteMemory(proc, sz * ((OPCODE_MAX_SIZE * 2) + JMP_ADDR_SIZE));

	DEBUG(LOG_DEFAULT, "[+] original opcodes buffer = %p\n", orig_buf);

	for (i = 0; i < sz; i++) {
		DEBUG(LOG_VERBOSE, "[+] next hook iteration\n");
		if (lst[i].fn_target == NULL) {
			DEBUG(LOG_DEFAULT, "can't find ptr, skipping\n");
			continue;
		}
		used += hook_function(proc,
		    lst[i].fn_target,
		    lst[i].fn_replacement,
		    ((void*)((DWORD_PTR)orig_buf + (DWORD_PTR)used)));
	}

	return true;
}

bool
patch_iat(void *img, void *target, void *replacement)
{
	DWORD oldProtect;
	bool ok = false;
	IMAGE_IMPORT_DESCRIPTOR *iid;

#if defined _WIN64
	PIMAGE_NT_HEADERS64 header = (PIMAGE_NT_HEADERS64)((LPBYTE)img +
			((PIMAGE_DOS_HEADER)img)->e_lfanew);
#else
	PIMAGE_NT_HEADERS32 header = (PIMAGE_NT_HEADERS32)((LPBYTE)img +
			((PIMAGE_DOS_HEADER)img)->e_lfanew);
#endif
	
	IMAGE_DATA_DIRECTORY *import = &header->OptionalHeader.
			DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

	if (import->VirtualAddress == 0 ||
	    import->Size < sizeof(IMAGE_IMPORT_DESCRIPTOR))
		return false;
	
	if (!VirtualProtectEx(mainCtx.handles.current_handle,
		    (LPVOID)((DWORD)img + import->VirtualAddress),
		    import->Size,
		    PAGE_EXECUTE_READWRITE,
		    &oldProtect)) {
		DEBUG(LOG_DEFAULT, "can't set access rights to target function: %d\n",
		    GetLastError());
		return false;
	}

	DEBUG(LOG_DEFAULT, "before iterate\n");
	for (iid = (IMAGE_IMPORT_DESCRIPTOR *)((LPBYTE)img + import->VirtualAddress);
	    iid->Characteristics != 0; 
	    iid++) {
#if defined _WIN64
		IMAGE_THUNK_DATA64 *originalThunk = (IMAGE_THUNK_DATA64 *)((LPBYTE)img +
		    iid->OriginalFirstThunk);
		IMAGE_THUNK_DATA64 *thunk         = (IMAGE_THUNK_DATA64 *)((LPBYTE)img +
		    iid->FirstThunk);
#else
		IMAGE_THUNK_DATA32 *originalThunk = (IMAGE_THUNK_DATA32 *)((LPBYTE)img +
		    iid->OriginalFirstThunk);
		IMAGE_THUNK_DATA32 *thunk         = (IMAGE_THUNK_DATA32 *)((LPBYTE)img +
		    iid->FirstThunk);
#endif
		for(; originalThunk->u1.Function != 0;
		    originalThunk++, thunk++)
			if((DWORD_PTR)target == thunk->u1.Function) {
				DEBUG(LOG_VERBOSE, "[+] ok,  function finded\n");
				thunk->u1.Function = (DWORD_PTR)replacement;
				ok = true;
			}
	}
	if (!VirtualProtectEx(mainCtx.handles.current_handle, (LPVOID)((DWORD)img + import->VirtualAddress),
	    import->Size, oldProtect, NULL)) {
		DEBUG(LOG_DEFAULT, "[-] can't bring back access rights: %d\n",
			GetLastError());
		//return false;
	}

	return ok;
}
