// test_inj.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"

#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <TlHelp32.h>

#include "common.h"
#include "corehook.h"
#include "coreinject.h"
#include "log.h"
#include "peutils.h"
#include "test_inj.h"
#include "utils.h"


char *dump_path = "C:\\Documents and Settings\\Admin\\Рабочий стол\\test_inj.txt";

#pragma comment(lib, "Kernel32")

struct MainCtx mainCtx;

#if IS_DEBUG > 0

struct DebugCtx debugCtx = {
	stderr,
	fopen,
	fwrite,
	fclose,
	fwprintf,
	fflush,
};

#endif

struct check_proc {
	wchar_t *pname;
	bool (*additional_check)(PROCESSENTRY32W *pe);
} monitored[] = {
	//{L"opera.exe", NULL},
	//{L"rabbit.exe", NULL},
	{L"notepad.exe", NULL},
	{L"chrome.exe", isParrentNotChrome},
	//{L"explorer.exe", NULL}
};


/* 
 * try to find function inside loaded module.
 * Tries to load not finded library when forceLoad flag activated.
 * 
 * We can't use debug output messages inside this function because
 * when we inject remote thread getFunctionAddress calls before debugCtx renewed
 */
FARPROC
getFunctionAddress(wchar_t *module, char *function, int forceLoad)
{
	HMODULE mod;
	
	mod = GetModuleHandle(module);
	if (mod == NULL) {
		int ret;

		if (!forceLoad)
			return NULL;
		mod = LoadLibrary(module);
		if (mod == NULL) {
			ret = GetLastError();
			return NULL;
		}
	}
	return GetProcAddress(mod, function);
}

static void WINAPI
prepare_debug_output()
{
#if IS_DEBUG > 0
	debugCtx.logPath = debugCtx.fopen(dump_path, "w");
#endif
}

static void WINAPI
close_debug_output()
{
#if IS_DEBUG > 0
	debugCtx.fclose(debugCtx.logPath);
#endif
}

DWORD WINAPI
injected_thread(LPVOID data)
{

	////renew information about our module
	if (!ctx_renew())
		ExitThread(0);
	
	prepare_debug_output();

	DEBUG(LOG_DEFAULT, "[+] Thread injected\n");
	DEBUG(LOG_DEFAULT, "[+] current module handle is %p\n", (void*)mainCtx.current_module);
	if (!hook_all(mainCtx.handles.current_handle)) {
		DEBUG(LOG_DEFAULT, "[-] can't hook\n");
	} else {
		DEBUG(LOG_DEFAULT, "[+] seems like hook is successfull\n");
	}

	int i = 10;
	while (i--) {
		DEBUG(LOG_DEFAULT, "another sleep...\n");
		Sleep(1000 * 10);
	}
	close_debug_output();
	
	ExitThread(0);
}

/*
 * Check is we running under acceptable Architecture
 * Only x86 supported now :(
 */
static bool
isAcceptableArch()
{
	SYSTEM_INFO info;

	GetSystemInfo(&info);

	if (info.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
		return true;

	return false;
}

bool
isParrentNotChrome(PROCESSENTRY32W *pe)
{
	
}

static void
nextProcessHandler(PROCESSENTRY32W *pe)
{
	int i;

	for (i = 0; i < ARRSZ(monitored); i++) {
			
		if (wcscmp(monitored[i].pname, pe->szExeFile) != 0)
			continue;
		if (monitored[i].additional_check != NULL &&
		    monitored[i].additional_check(pe) == false)
			continue;
		if (!inject_into_process(pe->th32ProcessID)) {
			myprintf("[-] inject into %s with pid %d failed\n",
			    pe->szExeFile,
			    pe->th32ProcessID);
		} else {
			DEBUG(LOG_DEFAULT, "[+] all ok with %s\n", pe->szExeFile);
		}
	}
}


int 
_tmain(int argc, _TCHAR* argv[])
{
	HANDLE snap;
	PROCESSENTRY32W pe;
	int err;



	if (!isAcceptableArch())
		return 0;

	err = 0;
	pe.dwSize = sizeof(PROCESSENTRY32W);

	//get current handle & module
	if (!ctx_renew())
		return false;

	mainCtx.current_module = GetModuleHandle(NULL);

	DEBUG(LOG_DEFAULT, "[+] current module size is %d\n", 
	    sizeof(mainCtx.current_module));

	snap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if(snap == INVALID_HANDLE_VALUE)
		error(1, "can't take snapshot");
	
	if (!Process32First(snap, &pe)) {
		err = 1; DEBUG(LOG_DEFAULT, "[-] last err = %d\n", GetLastError());
		goto finalize;
	}
	do {
		nextProcessHandler(pe);
	} while (Process32Next(snap, &pe));


finalize:
	CloseHandle(snap);
	
	//Wait!
	DEBUG(LOG_DEFAULT, "[~] err is %d\n", err);
	//getchar();
	return err;
}

